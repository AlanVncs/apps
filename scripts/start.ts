import "npm:@graphql-codegen/typescript";
import "npm:@graphql-codegen/typescript-operations";

import { CodegenConfig, generate } from "npm:@graphql-codegen/cli";
import {
  compile,
  Options as CompileOptions,
} from "npm:json-schema-to-typescript";
import { OpenAPIV3 } from "npm:openapi-types";
import { walk } from "std/fs/mod.ts";
import { dirname, join } from "std/path/mod.ts";
import { basename } from "std/path/win32.ts";

const OPENAPI_EXTENSION = ".openapi.json";
const GRAPHQL_EXTENSION = ".graphql.json";

const allOpenAPIPaths: string[] = [];
const allGraphqlPaths: string[] = [];

for await (const entry of walk(".")) {
  if (entry.isFile) {
    if (entry.path.endsWith(OPENAPI_EXTENSION)) {
      allOpenAPIPaths.push(entry.path);
    }
    if (entry.path.endsWith(GRAPHQL_EXTENSION)) {
      allGraphqlPaths.push(entry.path);
    }
  }
}

const toOutfile = (path: string) => path.replace(".json", ".gen.ts");

// transforms: /a/{b}/c => /a/:b/c
const toPathTemplate = (path: string) =>
  path.replace(/{/g, ":").replace(/}/g, "");

const generateOpenAPI = async () => {
  const isOpenAPIv3 = (x: any): x is OpenAPIV3.Document =>
    x?.openapi?.startsWith("3.");

  const isReferenceObject = (x: any): x is OpenAPIV3.ReferenceObject =>
    Boolean(x?.$ref);

  const BANNER_COMMENT = `
// DO NOT EDIT. This file is generated by deco.
// This file SHOULD be checked into source version control.
// To generate this file: deno run -A scripts/openAPI.ts

`;

  const HTTP_VERBS = ["get", "post", "put", "delete", "patch", "head"] as const;

  const COMPILE_OPTIONS: Partial<CompileOptions> = {
    bannerComment: "",
    unknownAny: true,
    additionalProperties: false,
    format: true,
  };

  const MEDIA_TYPE_JSON = "application/json";

  const AUTOGEN_TYPE_NAME = "Autogen";

  for (const path of allOpenAPIPaths) {
    const outfile = toOutfile(path);
    const types = [];

    console.info(`Generating OpenAPI types for specs at ${path}`);
    const document = JSON.parse(await Deno.readTextFile(path));

    const derrefObject = <T>(
      obj: T | OpenAPIV3.ReferenceObject,
    ): T | null => {
      if (isReferenceObject(obj)) {
        return obj.$ref.split("/").slice(1).reduce(
          (acc: any, curr) => acc?.[curr],
          document,
        ) as T;
      }

      if (!obj) return null;

      const ret: any = {};
      for (const [key, value] of Object.entries(obj)) {
        if (typeof value !== "object" && typeof value !== "symbol") {
          ret[key] = value;
        } else if (Array.isArray(value)) {
          ret[key] = value.map(derrefObject);
        } else {
          ret[key] = derrefObject(value);
        }
      }

      return ret;
    };

    if (!isOpenAPIv3(document)) {
      throw new Error("Only OpenAPI@3x is supported");
    }

    for (const [path, pathItem] of Object.entries(document.paths)) {
      const pathTemplate = toPathTemplate(path);

      for (const verb of HTTP_VERBS) {
        const item = pathItem?.[verb];

        if (!item) {
          continue;
        }

        const {
          parameters = [],
          requestBody,
          responses,
          summary,
          description,
        } = item;

        const paramsSchema = parameters
          .map((item) => isReferenceObject(item) ? derrefObject(item) : item)
          .reduce((schema, item) => {
            if (item.schema && item.in === "query") {
              schema.properties[item.name] = {
                description: item.description,
                ...item.schema,
              };

              if (item.required) {
                schema.required.push(item.name);
              }
            }

            return schema;
          }, {
            type: "object" as const,
            required: [] as string[],
            properties: {} as Record<string, OpenAPIV3.SchemaObject>,
          });

        const bodySchema = derrefObject(
          derrefObject(requestBody)?.content[MEDIA_TYPE_JSON]?.schema,
        );

        const ok = responses?.["200"] ||
          responses?.["201"] ||
          responses?.["206"];
        const responseSchema = derrefObject(
          derrefObject(ok)?.content?.[MEDIA_TYPE_JSON].schema,
        );

        console.info(bodySchema);

        const [searchParams, body, response] = await Promise.all(
          [
            // Object.keys(paramsSchema.properties).length > 0 && paramsSchema,
            bodySchema,
            // responseSchema,
          ]
            .map((schema) =>
              schema && compile(schema, AUTOGEN_TYPE_NAME, COMPILE_OPTIONS)
            ),
        );

        const docs = (description || summary) &&
          `/** @description ${description || summary} */`;

        const typed = `${docs}\n "${verb.toUpperCase()} ${pathTemplate}": {
              ${
          Object.entries({ searchParams, body, response })
            .filter((e) => Boolean(e[1]))
            .map(([key, value]) =>
              `${key}: ${
                value!.replace(`export interface ${AUTOGEN_TYPE_NAME}`, "")
                  .replace(`export type ${AUTOGEN_TYPE_NAME} = `, "")
              }`
            )
        }
            }`;

        types.push(typed);
      }
    }

    await Deno.writeTextFile(
      outfile,
      `${BANNER_COMMENT}export interface API {\n${types.join("\n")}\n}`,
    );

    // Format using deno
    const fmt = new Deno.Command(Deno.execPath(), { args: ["fmt", outfile] });
    await fmt.output();
  }
};

const generateGraphQL = async () => {
  for (const path of allGraphqlPaths) {
    const [folder, base] = [dirname(path), basename(path)];
    const [appEntrypoint, ...tail] = folder.split("/");

    console.info(`Generating GraphQL types for specs at ${folder}`);
    const config: CodegenConfig = {
      silent: true,
      schema: join(Deno.cwd(), path),
      documents: [`./**/*.ts`],
      generates: {
        [toOutfile(join(...tail, base))]: {
          plugins: [
            "typescript",
            "typescript-operations",
          ],
          config: {
            skipTypename: true,
            enumsAsTypes: true,
          },
        },
      },
    };

    await generate({ ...config, cwd: appEntrypoint }, true);
  }
};

const generateDeco = () => import("deco/scripts/apps/bundle.ts");

await generateOpenAPI();
await generateGraphQL();
await generateDeco();
